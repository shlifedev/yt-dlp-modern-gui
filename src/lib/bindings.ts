
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async checkDependencies() : Promise<Result<DependencyStatus, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_dependencies") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateYtdlp() : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_ytdlp") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDownloadQueue() : Promise<Result<DownloadTaskInfo[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_download_queue") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearCompleted() : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_completed") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async retryDownload(taskId: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("retry_download", { taskId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSettings() : Promise<Result<AppSettings, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateSettings(settings: AppSettings) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async selectDownloadDirectory() : Promise<Result<string | null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("select_download_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableBrowsers() : Promise<string[]> {
    return await TAURI_INVOKE("get_available_browsers");
},
async getDownloadHistory(page: number, pageSize: number, search: string | null) : Promise<Result<HistoryResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_download_history", { page, pageSize, search }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkDuplicate(videoId: string) : Promise<Result<DuplicateCheckResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_duplicate", { videoId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteHistoryItem(id: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_history_item", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getActiveDownloads() : Promise<Result<DownloadTaskInfo[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_active_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate if a URL is a valid YouTube URL
 */
async validateUrl(url: string) : Promise<Result<UrlValidation, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_url", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch video metadata using yt-dlp --dump-json
 */
async fetchVideoInfo(url: string) : Promise<Result<VideoInfo, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_video_info", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch playlist metadata and entries using yt-dlp --flat-playlist
 */
async fetchPlaylistInfo(url: string, page: number, pageSize: number) : Promise<Result<PlaylistResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_playlist_info", { url, page, pageSize }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch quick metadata via YouTube oEmbed API (~200ms vs ~12s for yt-dlp)
 */
async fetchQuickMetadata(url: string) : Promise<Result<QuickMetadata, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_quick_metadata", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startDownload(request: DownloadRequest) : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_download", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addToQueue(request: DownloadRequest) : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_to_queue", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelDownload(taskId: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download", { taskId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelAllDownloads() : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_all_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pauseDownload(taskId: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pause_download", { taskId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resumeDownload(taskId: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_download", { taskId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setMinimizeToTray(minimize: boolean, remember: boolean) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_minimize_to_tray", { minimize, remember }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentLogs() : Promise<string> {
    return await TAURI_INVOKE("get_recent_logs");
},
async getCachedDepStatus() : Promise<Result<FullDependencyStatus | null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_cached_dep_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkFullDependencies(force: boolean | null) : Promise<Result<FullDependencyStatus, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_full_dependencies", { force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async installDependency(depName: string) : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_dependency", { depName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async installAllDependencies() : Promise<Result<string[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_all_dependencies") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkDependencyUpdate(depName: string) : Promise<Result<DepUpdateInfo, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_dependency_update", { depName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateDependency(depName: string) : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_dependency", { depName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete an app-managed dependency binary from app_data_dir/bin/.
 */
async deleteAppManagedDep(depName: string) : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_app_managed_dep", { depName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Full factory reset: clear settings, databases (via live connections), binaries, and caches.
 * 
 * Databases are cleared through their live connections rather than deleting files,
 * which would leave orphaned in-memory connections and cause silent data loss.
 */
async resetAllData() : Promise<Result<string[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_all_data") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLogs(page: number, pageSize: number, level: string | null, category: string | null, search: string | null, since: number | null) : Promise<Result<LogQueryResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_logs", { page, pageSize, level, category, search, since }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLogStats() : Promise<Result<LogStats, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_log_stats") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearLogs(beforeTimestamp: number | null) : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_logs", { beforeTimestamp }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
depInstallEvent: DepInstallEvent,
globalDownloadEvent: GlobalDownloadEvent,
newLogEvent: NewLogEvent
}>({
depInstallEvent: "dep-install-event",
globalDownloadEvent: "global-download-event",
newLogEvent: "new-log-event"
})

/** user-defined constants **/



/** user-defined types **/

export type AppError = { FileError: string } | { Custom: string } | { BinaryNotFound: string } | { DownloadError: string } | { MetadataError: string } | { DatabaseError: string } | { NetworkError: string } | { InvalidUrl: string } | { DependencyInstallError: string } | { ChecksumError: string } | { NotImplemented: string }
export type AppSettings = { downloadPath: string; defaultQuality: string; maxConcurrent: number; filenameTemplate: string; cookieBrowser: string | null; autoUpdateYtdlp: boolean; useAdvancedTemplate: boolean; templateUploaderFolder: boolean; templateUploadDate: boolean; templateVideoId: boolean; language: string | null; theme: string | null; minimizeToTray: boolean | null; 
/**
 * Dependency resolution mode: "external" (app-managed) or "system" (system PATH only)
 */
depMode: string; 
/**
 * Whether the initial setup wizard has been completed
 */
setupCompleted: boolean }
export type DepInfo = { installed: boolean; version: string | null; source: DepSource; path: string | null }
export type DepInstallEvent = { depName: string; stage: DepInstallStage; percent: number; bytesDownloaded: number; bytesTotal: number | null; message: string | null }
export type DepInstallStage = "Downloading" | "Verifying" | "Extracting" | "Completing" | "Failed"
export type DepSource = "AppManaged" | "SystemPath" | "NotFound"
export type DepUpdateInfo = { currentVersion: string | null; latestVersion: string; updateAvailable: boolean }
export type DependencyStatus = { ytdlpInstalled: boolean; ytdlpVersion: string | null; ffmpegInstalled: boolean; ffmpegVersion: string | null; 
/**
 * Diagnostic info when ytdlp check fails (path tried, error reason)
 */
ytdlpDebug: string | null }
export type DownloadRequest = { videoUrl: string; videoId: string; title: string; formatId: string; qualityLabel: string; outputDir: string | null; cookieBrowser: string | null }
export type DownloadStatus = "pending" | "downloading" | "paused" | "completed" | "failed" | "cancelled"
export type DownloadTaskInfo = { id: number; videoUrl: string; videoId: string; title: string; formatId: string; qualityLabel: string; outputPath: string; status: DownloadStatus; progress: number; speed: string | null; eta: string | null; errorMessage: string | null; createdAt: number; completedAt: number | null }
export type DuplicateCheckResult = { inHistory: boolean; inQueue: boolean; historyItem: HistoryItem | null }
export type FormatInfo = { formatId: string; ext: string; resolution: string | null; qualityLabel: string | null; filesize: number | null; vcodec: string | null; acodec: string | null; hasVideo: boolean; hasAudio: boolean }
export type FullDependencyStatus = { ytdlp: DepInfo; ffmpeg: DepInfo; deno: DepInfo }
export type GlobalDownloadEvent = { taskId: number; eventType: string; percent: number | null; speed: string | null; eta: string | null; filePath: string | null; fileSize: number | null; message: string | null }
export type HistoryItem = { id: number; videoUrl: string; videoId: string; title: string; qualityLabel: string; format: string; filePath: string; fileSize: number | null; downloadedAt: number }
export type HistoryResult = { items: HistoryItem[]; totalCount: number; page: number; pageSize: number }
export type LogEntry = { id: number; timestamp: number; level: string; category: string; message: string; details: string | null }
export type LogQueryResult = { items: LogEntry[]; totalCount: number; page: number; pageSize: number }
export type LogStats = { totalCount: number; errorCount: number; warnCount: number; infoCount: number }
export type NewLogEvent = { entry: LogEntry }
export type PlaylistEntry = { url: string; videoId: string; title: string | null; duration: number | null; thumbnail: string | null }
export type PlaylistResult = { playlistId: string; title: string; url: string; videoCount: number | null; channelName: string | null; entries: PlaylistEntry[] }
export type QuickMetadata = { videoId: string; title: string; channel: string; channelUrl: string; thumbnail: string }
export type UrlType = "video" | "channel" | "playlist" | "unknown"
export type UrlValidation = { valid: boolean; urlType: UrlType; normalizedUrl: string | null; videoId: string | null }
export type VideoInfo = { url: string; videoId: string; title: string; thumbnail: string; duration: number; uploadDate: string; channel: string; channelUrl: string; formats: FormatInfo[]; filesizeApprox: number | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
