
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async incrementCounter(current: number) : Promise<number> {
    return await TAURI_INVOKE("increment_counter", { current });
},
async checkDependencies() : Promise<Result<DependencyStatus, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_dependencies") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async installDependencies(onEvent: TAURI_CHANNEL<InstallEvent>) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_dependencies", { onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateYtdlp() : Promise<Result<string, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_ytdlp") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDownloadQueue() : Promise<Result<DownloadTaskInfo[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_download_queue") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearCompleted() : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_completed") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async retryDownload(taskId: number, onEvent: TAURI_CHANNEL<DownloadEvent>) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("retry_download", { taskId, onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSettings() : Promise<Result<AppSettings, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateSettings(settings: AppSettings) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_settings", { settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async selectDownloadDirectory() : Promise<Result<string | null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("select_download_directory") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAvailableBrowsers() : Promise<string[]> {
    return await TAURI_INVOKE("get_available_browsers");
},
async getDownloadHistory(page: number, pageSize: number, search: string | null) : Promise<Result<HistoryResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_download_history", { page, pageSize, search }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkDuplicate(videoId: string) : Promise<Result<HistoryItem | null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_duplicate", { videoId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteHistoryItem(id: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_history_item", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getActiveDownloads() : Promise<Result<DownloadTaskInfo[], AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_active_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate if a URL is a valid YouTube URL
 */
async validateUrl(url: string) : Promise<Result<UrlValidation, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_url", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch video metadata using yt-dlp --dump-json
 */
async fetchVideoInfo(url: string) : Promise<Result<VideoInfo, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_video_info", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Fetch playlist metadata and entries using yt-dlp --flat-playlist
 */
async fetchPlaylistInfo(url: string, page: number, pageSize: number) : Promise<Result<PlaylistResult, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fetch_playlist_info", { url, page, pageSize }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startDownload(request: DownloadRequest, onEvent: TAURI_CHANNEL<DownloadEvent>) : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_download", { request, onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addToQueue(request: DownloadRequest) : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_to_queue", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelDownload(taskId: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_download", { taskId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelAllDownloads() : Promise<Result<number, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_all_downloads") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pauseDownload(taskId: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("pause_download", { taskId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resumeDownload(taskId: number) : Promise<Result<null, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resume_download", { taskId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
globalDownloadEvent: GlobalDownloadEvent
}>({
globalDownloadEvent: "global-download-event"
})

/** user-defined constants **/



/** user-defined types **/

export type AppError = { FileError: string } | { Custom: string } | { BinaryNotFound: string } | { DownloadError: string } | { MetadataError: string } | { DatabaseError: string } | { NetworkError: string } | { InvalidUrl: string }
export type AppSettings = { downloadPath: string; defaultQuality: string; maxConcurrent: number; filenameTemplate: string; cookieBrowser: string | null; autoUpdateYtdlp: boolean; useAdvancedTemplate: boolean; templateUploaderFolder: boolean; templateUploadDate: boolean; templateVideoId: boolean }
export type DependencyStatus = { ytdlpInstalled: boolean; ytdlpVersion: string | null; ffmpegInstalled: boolean; ffmpegVersion: string | null }
export type DownloadEvent = { event: "started"; data: { task_id: number } } | { event: "progress"; data: { task_id: number; percent: number; speed: string; eta: string } } | { event: "postprocessing"; data: { task_id: number; status: string } } | { event: "completed"; data: { task_id: number; file_path: string; file_size: number } } | { event: "error"; data: { task_id: number; message: string } }
export type DownloadRequest = { videoUrl: string; videoId: string; title: string; formatId: string; qualityLabel: string; outputDir: string | null; cookieBrowser: string | null }
export type DownloadStatus = "pending" | "downloading" | "paused" | "completed" | "failed" | "cancelled"
export type DownloadTaskInfo = { id: number; videoUrl: string; videoId: string; title: string; formatId: string; qualityLabel: string; outputPath: string; status: DownloadStatus; progress: number; speed: string | null; eta: string | null; errorMessage: string | null; createdAt: number; completedAt: number | null }
export type FormatInfo = { formatId: string; ext: string; resolution: string | null; qualityLabel: string | null; filesize: number | null; vcodec: string | null; acodec: string | null; hasVideo: boolean; hasAudio: boolean }
export type GlobalDownloadEvent = { taskId: number; eventType: string; percent: number | null; speed: string | null; eta: string | null; filePath: string | null; fileSize: number | null; message: string | null }
export type HistoryItem = { id: number; videoUrl: string; videoId: string; title: string; qualityLabel: string; format: string; filePath: string; fileSize: number | null; downloadedAt: number }
export type HistoryResult = { items: HistoryItem[]; totalCount: number; page: number; pageSize: number }
export type InstallEvent = { event: "progress"; data: { dependency: string; message: string } } | { event: "completed"; data: { dependency: string; message: string } } | { event: "error"; data: { dependency: string; message: string } }
export type PlaylistEntry = { url: string; videoId: string; title: string | null; duration: number | null; thumbnail: string | null }
export type PlaylistResult = { playlistId: string; title: string; url: string; videoCount: number | null; channelName: string | null; entries: PlaylistEntry[] }
export type UrlType = "video" | "channel" | "playlist" | "unknown"
export type UrlValidation = { valid: boolean; urlType: UrlType; normalizedUrl: string | null }
export type VideoInfo = { url: string; videoId: string; title: string; thumbnail: string; duration: number; uploadDate: string; channel: string; channelUrl: string; formats: FormatInfo[]; filesizeApprox: number | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
