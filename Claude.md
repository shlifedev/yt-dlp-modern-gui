# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

Tauri 2.0 desktop application: a yt-dlp GUI for downloading YouTube videos. SvelteKit frontend with Rust backend. Root page (`/`) redirects to `/tools/ytdlp`.

## Build Commands

```bash
# Development (runs both frontend + backend)
bun run tauri dev

# Frontend only
bun run dev               # Vite dev server
bun run check             # Svelte/TypeScript type check

# Backend only (run from repo root, not src-tauri/)
cd src-tauri && cargo check && cd ..
cd src-tauri && cargo fmt && cargo clippy && cd ..

# Run Rust tests
cd src-tauri && cargo test && cd ..

# Production build
bun run tauri build
```

## Before Committing

```bash
cd src-tauri && cargo fmt && cargo clippy && cd ..
bun run check
```

## Architecture

### Backend Module Structure (`src-tauri/src/`)

```
lib.rs              # App init, state setup (AppState, DbState, DownloadManagerState)
command.rs          # Legacy/simple Tauri commands
modules/
  types.rs          # AppError enum (thiserror-based, 7 variants)
  logger.rs         # Logging utility
ytdlp/
  mod.rs            # Module re-exports
  types.rs          # All shared types: VideoInfo, DownloadRequest, DownloadStatus, AppSettings, events, etc.
  commands.rs       # Tauri commands: check_dependencies, get/update_settings, download queue, history CRUD
  download.rs       # DownloadManager (concurrent download slots via AtomicU32 + CAS), queue processing
  metadata.rs       # URL validation (regex), fetch_video_info/fetch_playlist_info via yt-dlp --dump-json
  binary.rs         # yt-dlp/ffmpeg binary resolution (local app dir -> system PATH fallback, RwLock cache)
  progress.rs       # Parse yt-dlp progress output (regex-based, has unit tests)
  settings.rs       # Settings via tauri-plugin-store (settings.json)
  db.rs             # SQLite via rusqlite: downloads table (queue) + history table
```

### Key Architectural Patterns

**Download Pipeline**: URL input -> `validate_url` -> `fetch_video_info`/`fetch_playlist_info` -> `add_to_queue` -> `DownloadManager.try_acquire` (CAS loop for concurrency control) -> `execute_download` (spawns yt-dlp process) -> `process_next_pending` (auto-dequeue)

**State Management (Rust side)**:
- `DbState = Arc<Database>` - SQLite connection wrapped in `Mutex<Connection>`
- `DownloadManagerState = Arc<DownloadManager>` - concurrent slot tracking via `AtomicU32`, cancel via `watch::channel`
- Settings stored in `tauri-plugin-store` (separate from SQLite)

**Event System**: Global events emitted via `app.emit("download-event", GlobalDownloadEvent)` for progress/completion/errors. Frontend listens via `@tauri-apps/api/event`. The `Channel<DownloadEvent>` parameter in `start_download` is legacy (unused, delegates to `add_to_queue`).

**TypeScript Bindings**: Auto-generated by `tauri-specta` into `src/lib/bindings.ts` (DO NOT EDIT). Regenerated on `bun run tauri dev` in debug mode. All commands return `Result<T, AppError>` which becomes `{ status: "ok", data: T } | { status: "error", error: AppError }` in TypeScript.

### Frontend Structure (`src/`)

```
routes/
  +page.svelte              # Redirect to /tools/ytdlp
  +layout.svelte            # Minimal root layout (just renders children)
  tools/ytdlp/
    +layout.svelte          # App shell: top nav, dependency check/install, download queue popup
    +page.svelte            # Main page: URL input, video/playlist analysis, format/quality selection, download
    queue/+page.svelte      # Full download queue view
    history/+page.svelte    # Download history with search/pagination
    settings/+page.svelte   # Settings page
```

**UI Stack**: Tailwind CSS v4, Skeleton UI v4 (`@skeletonlabs/skeleton-svelte`), Material Symbols icons. Custom CSS variables: `yt-bg`, `yt-surface`, `yt-highlight`, `yt-primary`.

## Conventions

### Rust
- All Tauri commands use `#[tauri::command]` + `#[specta::specta]`
- After creating a command: add to `collect_commands![]` in `lib.rs`, run app to regenerate bindings
- Events: derive `tauri_specta::Event`, register in `collect_events![]`
- Types for frontend: `#[serde(rename_all = "camelCase")]` + `specta::Type`
- Error variants in `AppError` (modules/types.rs): use domain-specific variants, not `Custom`
- Mutex poisoning: use `unwrap_or_else(|e| e.into_inner())` pattern (see db.rs, binary.rs)

### Svelte/TypeScript
- Svelte 5 runes: `$state()`, `$derived()`, `$effect()`, `$props()`
- No semicolons, double quotes, 2-space indent
- Import commands from `$lib/bindings`, not raw `invoke()`
- Error extraction: `Object.values(err)[0]` pattern for AppError variants

### Adding a New Command
1. Define in appropriate file with `#[tauri::command]` + `#[specta::specta]`
2. Add to `collect_commands![]` in `lib.rs`
3. Run `bun run tauri dev` to regenerate `src/lib/bindings.ts`
4. Use via `commands.myCommand()` in frontend
